name: Deploy MCP Server to AWS

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging
          - development

env:
  AWS_REGION: ca-central-1
  ECR_REPO_NAME: mcp-server-repo
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    outputs:
      image-url: ${{ steps.build.outputs.image-url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Check if ECR repository exists
        id: check-ecr
        run: |
          if aws ecr describe-repositories --repository-names ${{ env.ECR_REPO_NAME }} 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create ECR repository if it doesn't exist
        if: steps.check-ecr.outputs.exists == 'false'
        run: |
          aws ecr create-repository \
            --repository-name ${{ env.ECR_REPO_NAME }} \
            --image-scanning-configuration scanOnPush=true \
            --region ${{ env.AWS_REGION }}

      - name: Build, tag, and push Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          cd mcp
          docker build -t $ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:${{ env.IMAGE_TAG }} .
          docker tag $ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:${{ env.IMAGE_TAG }} $ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:latest
          docker push $ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:${{ env.IMAGE_TAG }}
          docker push $ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:latest
          echo "image-url=$ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT

  deploy-infrastructure:
    name: Deploy Infrastructure with Terraform
    runs-on: ubuntu-latest
    needs: build-and-push
    outputs:
      cluster-name: ${{ steps.outputs.outputs.cluster-name }}
      service-name: ${{ steps.outputs.outputs.service-name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.1

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Terraform Plan
        working-directory: ./terraform
        run: |
          terraform plan \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="environment=${{ github.event.inputs.environment || 'production' }}" \
            -var="mcp_server_name=${{ env.ECR_REPO_NAME }}" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: outputs
        working-directory: ./terraform
        run: |
          echo "cluster-name=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_OUTPUT
          echo "service-name=$(terraform output -raw ecs_service_name)" >> $GITHUB_OUTPUT

  update-service:
    name: Update ECS Service
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure]

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Force new deployment
        run: |
          aws ecs update-service \
            --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
            --service ${{ needs.deploy-infrastructure.outputs.service-name }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

  get-deployment-info:
    name: Get Deployment Information
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, update-service]

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Task Public IP
        id: get-ip
        run: |
          # Get task ARN
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
            --service-name ${{ needs.deploy-infrastructure.outputs.service-name }} \
            --region ${{ env.AWS_REGION }} \
            --query 'taskArns[0]' \
            --output text)

          if [ "$TASK_ARN" != "None" ] && [ ! -z "$TASK_ARN" ]; then
            # Get ENI ID
            ENI_ID=$(aws ecs describe-tasks \
              --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
              --tasks $TASK_ARN \
              --region ${{ env.AWS_REGION }} \
              --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
              --output text)
            
            if [ "$ENI_ID" != "None" ] && [ ! -z "$ENI_ID" ]; then
              # Get public IP
              PUBLIC_IP=$(aws ec2 describe-network-interfaces \
                --network-interface-ids $ENI_ID \
                --region ${{ env.AWS_REGION }} \
                --query 'NetworkInterfaces[0].Association.PublicIp' \
                --output text)
              
              echo "public-ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
              echo "success=true" >> $GITHUB_OUTPUT
            else
              echo "success=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      - name: Display Deployment Information
        if: steps.get-ip.outputs.success == 'true'
        run: |
          echo "## 🎉 Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🌐 Endpoints" >> $GITHUB_STEP_SUMMARY
          echo "- **MCP Server**: http://${{ steps.get-ip.outputs.public-ip }}:8000/mcp/" >> $GITHUB_STEP_SUMMARY
          echo "- **Health Check**: http://${{ steps.get-ip.outputs.public-ip }}:8000/health" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📦 Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ github.event.inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ env.IMAGE_TAG }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Region**: ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: ${{ needs.deploy-infrastructure.outputs.cluster-name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Service**: ${{ needs.deploy-infrastructure.outputs.service-name }}" >> $GITHUB_STEP_SUMMARY

      - name: Test Health Endpoint
        if: steps.get-ip.outputs.success == 'true'
        run: |
          echo "Testing health endpoint..."
          max_attempts=10
          attempt=0

          while [ $attempt -lt $max_attempts ]; do
            if curl -f http://${{ steps.get-ip.outputs.public-ip }}:8000/health; then
              echo "✅ Health check passed!"
              break
            else
              echo "Attempt $((attempt + 1))/$max_attempts failed. Waiting 10 seconds..."
              sleep 10
              attempt=$((attempt + 1))
            fi
          done

          if [ $attempt -eq $max_attempts ]; then
            echo "⚠️ Health check failed after $max_attempts attempts"
            exit 1
          fi
